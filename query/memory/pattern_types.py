"""
This module defines common types and models for cross-source pattern detection.

Project Indaleko
Copyright (C) 2024-2025 Tony Mason and contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import uuid
from datetime import UTC, datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field


class DataSourceType(str, Enum):
    """Type of data source for cross-source pattern analysis."""

    NTFS = "ntfs"
    COLLABORATION = "collaboration"
    LOCATION = "location"
    AMBIENT = "ambient"
    TASK = "task"
    SEMANTIC = "semantic"
    QUERY = "query"


class SuggestionType(str, Enum):
    """Types of proactive suggestions that can be offered."""

    QUERY = "query"
    CONTENT = "content"
    ORGANIZATION = "organization"
    REMINDER = "reminder"
    RELATED_CONTENT = "related_content"
    SEARCH_STRATEGY = "search_strategy"
    GOAL_PROGRESS = "goal_progress"


class SuggestionPriority(str, Enum):
    """Priority levels for suggestions."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ProactiveSuggestion(BaseModel):
    """A proactive suggestion generated by the Archivist."""

    suggestion_id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique identifier for this suggestion",
    )
    suggestion_type: SuggestionType = Field(..., description="Type of suggestion")
    title: str = Field(..., description="Brief title for the suggestion")
    content: str = Field(..., description="Detailed content of the suggestion")
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(UTC),
        description="When this suggestion was created",
    )
    expires_at: datetime | None = Field(
        None, description="When this suggestion expires (if applicable)",
    )
    priority: SuggestionPriority = Field(
        default=SuggestionPriority.MEDIUM,
        description="Priority level of the suggestion",
    )
    confidence: float = Field(
        default=0.5, description="Confidence in this suggestion (0.0-1.0)",
    )
    context: dict[str, Any] = Field(
        default_factory=dict,
        description="Contextual information related to this suggestion",
    )
    related_queries: list[str] = Field(
        default_factory=list, description="Queries related to this suggestion",
    )
    dismissed: bool = Field(
        default=False, description="Whether this suggestion has been dismissed",
    )
    acted_upon: bool = Field(
        default=False, description="Whether the user has acted upon this suggestion",
    )
    feedback: float | None = Field(
        None, description="User feedback on this suggestion (-1.0 to 1.0)",
    )

    def is_expired(self) -> bool:
        """Check if the suggestion has expired."""
        if not self.expires_at:
            return False
        return datetime.now(UTC) > self.expires_at

    def mark_dismissed(self) -> None:
        """Mark this suggestion as dismissed."""
        self.dismissed = True

    def mark_acted_upon(self) -> None:
        """Mark this suggestion as acted upon."""
        self.acted_upon = True

    def provide_feedback(self, feedback_value: float) -> None:
        """
        Provide feedback on the suggestion.

        Args:
            feedback_value: Feedback value between -1.0 (negative) and 1.0 (positive)
        """
        if -1.0 <= feedback_value <= 1.0:
            self.feedback = feedback_value

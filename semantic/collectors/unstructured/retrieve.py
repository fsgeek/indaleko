"""
This extracts the semantic metadata of files, specified in the
output of lookup.py, using unstructured. The output is parsed into
a jsonl file where each line represents one file object.

Project Indaleko
Copyright (C) 2024-2025 Tony Mason

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

# standard library imports
import configparser
import os
import sys

import docker

#  Find Indaleko Root
if os.environ.get("INDALEKO_ROOT") is None:
    current_path = os.path.dirname(os.path.abspath(__file__))
    while not os.path.exists(os.path.join(current_path, "Indaleko.py")):
        current_path = os.path.dirname(current_path)
    os.environ["INDALEKO_ROOT"] = current_path
    sys.path.append(current_path)

# third-party imports
from icecream import ic

# Indaleko Imports
from Indaleko import Indaleko


class UnstructuredRetrieval:

    unstructured_config_file_name = "unstructured_config.ini"
    docker_client = docker.from_env()

    def __init__(self, **kwargs):
        self.load_config()

    def load_config(self):
        unstructured_config_file = os.path.join(
            Indaleko.default_config_dir,
            self.unstructured_config_file_name,
        )
        self.unstructured_config = configparser.ConfigParser()
        self.unstructured_config.read(unstructured_config_file, encoding="utf-8-sig")

    def create_bind_mounts(self):
        """Creates a dictionary with the necessary bind mounts to initialize the Docker container with.
        Currently sets up 3 bind mounts listed in the unstructured config file
        """
        bind_mounts = {}

        # Create bind mount for disk
        bind_mounts[self.unstructured_config["VOLUMES"]["HostDrive"]] = {
            "bind": self.unstructured_config["VOLUMES"]["HostDriveMount"],
            "mode": "rw",
        }

        # Create bind mount for project directory
        bind_mounts[self.unstructured_config["VOLUMES"]["ProjectDir"]] = {
            "bind": self.unstructured_config["VOLUMES"]["ProjectDirMount"],
            "mode": "rw",
        }

        # Create bind mount for Data I/O
        bind_mounts[self.unstructured_config["DATA"]["UnstructuredDataDir"]] = {
            "bind": self.unstructured_config["VOLUMES"]["UnstructuredDataDirMount"],
            "mode": "rw",
        }

        return bind_mounts

    def remove_existing_container(self, container_name):
        """Removes any existing containers with the provided name.
        Does nothing if the container does not exist
        """
        containers = self.docker_client.containers.list(all=True)
        if container_name in containers:
            container = self.docker_client.containers.get(container_name)
            ic(f"Container with name '{container_name}' already exists.")
            ic(f"Removing existing container '{container_name}'")
            if container.status == "running":
                container.stop()
            container.remove()

    def windows_to_unix_path(self, windows_path):
        normalized_path = os.path.normpath(windows_path)
        linux_path = normalized_path.replace("\\", "/")
        return linux_path

    def retrieve(self, container_name):
        """
        Extract information in files specified in the input file generated by lookup.
        This creates a docker container according to the specifications in the configuration file
        and runs a python script to extract information using the unstructured library

        Future Additions:
        - Run multiple containers in parallel (DIFFICULT!)
        """
        ic(
            f"Running the Docker container '{container_name}' with necessary volume mounts...",
        )
        bind_mounts = self.create_bind_mounts()
        self.remove_existing_container(container_name)

        # Retrieve necessary variables
        unix_data_dir_mount = self.unstructured_config["VOLUMES"]["UnstructuredDataDirMount"]
        unix_project_dir_mount = self.unstructured_config["VOLUMES"]["ProjectDirMount"]
        unstructured_image_name = self.unstructured_config["DOCKER"]["dockerimage"]
        unstructured_image_tag = self.unstructured_config["DOCKER"]["dockertag"]

        # Unix path of Python script, input file, output file
        unix_script_path = self.windows_to_unix_path(
            self.unstructured_config["DATA"]["ScriptsDir"],
        )
        unix_input_path = f"{unix_data_dir_mount}/{self.unstructured_config['DATA']['InputFileName']}"
        unix_output_path = f"{unix_data_dir_mount}/{self.unstructured_config['DATA']['OutputFileName']}"

        # Run Docker Container
        logs = self.docker_client.containers.run(
            image=f"{unstructured_image_name}:{unstructured_image_tag}",
            command=[
                "python3",
                f"{unix_project_dir_mount}/{unix_script_path}",
                unix_input_path,
                unix_output_path,
            ],
            name=container_name,
            mem_limit="5g",  # Change if required
            remove=True,
            stdin_open=True,
            volumes=bind_mounts,  # Bind mounts
            stdout=True,
            stderr=True,
        )

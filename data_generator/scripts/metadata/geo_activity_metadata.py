"""Geo Activity Metadata Generator."""

import random
import uuid

from datetime import datetime
from typing import Any

from geopy.distance import geodesic
from geopy.geocoders import Nominatim

from activity.collectors.location.data_models.windows_gps_location_data_model import (
    WindowsGPSLocationDataModel,
)
from activity.collectors.location.data_models.windows_gps_satellite_data import (
    WindowsGPSLocationSatelliteDataModel,
)
from activity.data_model.activity import IndalekoActivityDataModel
from data_generator.scripts.metadata.activity_metadata import ActivityMetadata
from data_models.i_uuid import IndalekoUUIDDataModel
from data_models.record import IndalekoRecordDataModel
from data_models.semantic_attribute import IndalekoSemanticAttributeDataModel


class GeoActivityData(ActivityMetadata):
    """
    Subclass of Activity Metadata.

    Generates Geographical Location Metadata.
    """

    DEFAULT_MIN_ALT = -10
    DEFAULT_MAX_ALT = 1000
    DEFAULT_MIN_LAT = -90
    DEFAULT_MAX_LAT = 90
    DEFAULT_MIN_LONG = -180
    DEFAULT_MAX_LONG = 180

    def __init__(self, selected_ac_md: dict) -> None:
        """Initialize the object."""
        super().__init__(selected_ac_md)
        self.saved_geo_loc = None

    def generate_metadata(
        self,
        **kwargs: dict[str, Any],
    ) -> IndalekoActivityDataModel:
        """Generate the metadata."""
        record_kwargs = kwargs.get("record_kwargs")
        timestamps = kwargs.get("timestamps")
        is_truth_file = kwargs.get("is_truth_file")
        truth_like = kwargs.get("truth_like")
        truthlike_attributes = kwargs.get("truthlike_attributes")
        is_truth_file = self._define_truth_attribute(
            "geo_location",
            is_truth_file,
            truth_like,
            truthlike_attributes,
        )
        return self._generate_geo_metadata(record_kwargs, timestamps, is_truth_file)

    def _generate_geo_metadata(
        self,
        record_kwargs: IndalekoRecordDataModel | None,
        timestamps: dict[str, datetime],
        is_truth_file: bool,  # noqa: FBT001
    ) -> IndalekoActivityDataModel:
        """Creates the geographical semantic data."""
        geo_timestamp = self._generate_ac_timestamp(
            is_truth_file,
            timestamps,
            "geo_location",
        )
        activity_geo_loc = self._generate_geo_context(is_truth_file)
        activity_geo_md = self._generate_WindowsGPSLocation(
            activity_geo_loc,
            geo_timestamp,
        )
        
        # Create a Record if none was provided
        if record_kwargs is None:
            from data_models.source_identifier import IndalekoSourceIdentifierDataModel
            
            source_identifier = IndalekoSourceIdentifierDataModel(
                Identifier=uuid.uuid4(),
                Version="1.0",
                Description="Generated by GeoActivityData._generate_geo_metadata",
            )
            
            record_kwargs = IndalekoRecordDataModel(
                SourceIdentifier=source_identifier,
            )

        uuid_longitude = uuid.uuid4()
        uuid_latitude = uuid.uuid4()
        uuid_accuracy = uuid.uuid4()

        longitude = IndalekoUUIDDataModel(Identifier=uuid_longitude, Label="Longitude")
        latitude = IndalekoUUIDDataModel(Identifier=uuid_latitude, Label="Latitude")
        accuracy = IndalekoUUIDDataModel(Identifier=uuid_accuracy, Label="Accuracy")

        semantic_attributes = [
            IndalekoSemanticAttributeDataModel(
                Identifier=longitude,
                Value=activity_geo_md.Location.longitude,
            ),
            IndalekoSemanticAttributeDataModel(
                Identifier=latitude,
                Value=activity_geo_md.Location.latitude,
            ),
            IndalekoSemanticAttributeDataModel(
                Identifier=accuracy,
                Value=activity_geo_md.Location.accuracy,
            ),
        ]

        # timestamp is set to when the activity data is collected
        geo_activity_context = IndalekoActivityDataModel(
            Record=record_kwargs,
            Timestamp=geo_timestamp,
            SemanticAttributes=semantic_attributes,
        )

        _unused_data_providers = """
        longitude_data_provider = ActivityDataModel(Provider = uuid.uuid4(),
            ProviderReference=UUID_longitude)
        latitude_data_provider = ActivityDataModel(Provider = uuid.uuid4(),
            ProviderReference=UUID_latitude)
        accuracy_data_provider = ActivityDataModel(Provider = uuid.uuid4(),
            ProviderReference=UUID_accuracy)
        geo_activity_service = IndalekoActivityContextDataModel(Handle=uuid.uuid4(),
            Timestamp=geo_timestamp, Cursors=[longitude_data_provider,
            latitude_data_provider,accuracy_data_provider])
        """
        return geo_activity_context

    def get_saved_geolocation(self) -> dict[str, float]:
        """Return saved geolocation."""
        return self.saved_geo_loc

    def _generate_geo_context(  # noqa: PLR0915
            self,
            is_truth_file: bool = True,  # noqa: FBT001, FBT002
    ) -> dict[str, Any]:
        """
        Generate geo location.

        Generates a geographical activity context based on the location given:
        self.selected_md["geo_location"] = {'location': str, 'command': str}
        """
        location_dict = {}
        delta = 5

        latitude = None
        longitude = None
        altitude = None

        if "geo_location" in self.selected_md:
            geo_location = self.selected_md["geo_location"]["location"]
            geo_command = self.selected_md["geo_location"]["command"]
            # run only once to initialize the saved location
            if not self.saved_geo_loc:
                self.saved_geo_loc = self._save_location(geo_location, geo_command)
            if geo_command == "at":
                if is_truth_file:
                    # geo location generator that given a city, generates longitude and latitude
                    latitude = self.saved_geo_loc["latitude"]
                    longitude = self.saved_geo_loc["longitude"]
                    altitude = self.saved_geo_loc["altitude"]

                else:
                    truth_latitude = self.saved_geo_loc["latitude"]
                    truth_longitude = self.saved_geo_loc["longitude"]
                    truth_altitude = self.saved_geo_loc["altitude"]

                    max_lat = min(
                        GeoActivityData.DEFAULT_MAX_LAT,
                        truth_latitude + delta,
                    )
                    min_lat = max(
                        GeoActivityData.DEFAULT_MIN_LAT,
                        truth_latitude - delta,
                    )
                    max_long = min(
                        GeoActivityData.DEFAULT_MAX_LONG,
                        truth_longitude + delta,
                    )
                    min_long = max(
                        GeoActivityData.DEFAULT_MIN_LONG,
                        truth_longitude - delta,
                    )
                    min_alt = max(
                        GeoActivityData.DEFAULT_MIN_ALT,
                        truth_altitude - delta,
                    )
                    max_alt = min(
                        GeoActivityData.DEFAULT_MAX_ALT,
                        truth_altitude + delta,
                    )

                    latitude = self._check_return_value_within_range(
                        GeoActivityData.DEFAULT_MIN_LAT,
                        GeoActivityData.DEFAULT_MAX_LAT,
                        min_lat,
                        max_lat,
                        random.uniform,
                    )

                    longitude = self._check_return_value_within_range(
                        GeoActivityData.DEFAULT_MIN_LONG,
                        GeoActivityData.DEFAULT_MAX_LONG,
                        min_long,
                        max_long,
                        random.uniform,
                    )

                    altitude = self._check_return_value_within_range(
                        GeoActivityData.DEFAULT_MIN_ALT,
                        GeoActivityData.DEFAULT_MAX_ALT,
                        min_alt,
                        max_alt,
                        random.uniform,
                    )

            elif geo_command == "within":
                north_bound = self.saved_geo_loc["latitude"][0]
                south_bound = self.saved_geo_loc["latitude"][1]
                east_bound = self.saved_geo_loc["longitude"][0]
                west_bound = self.saved_geo_loc["longitude"][1]
                altitude = self.saved_geo_loc["altitude"]

                if is_truth_file:
                    latitude = random.uniform(north_bound, south_bound)  # noqa: S311
                    longitude = random.uniform(east_bound, west_bound)  # noqa: S311

                else:
                    max_lat = min(GeoActivityData.DEFAULT_MAX_LAT, north_bound + delta)
                    min_lat = max(GeoActivityData.DEFAULT_MIN_LAT, south_bound - delta)
                    max_long = min(GeoActivityData.DEFAULT_MAX_LONG, east_bound + delta)
                    min_long = max(GeoActivityData.DEFAULT_MIN_LONG, west_bound - delta)
                    min_alt = max(GeoActivityData.DEFAULT_MIN_ALT, altitude - delta)
                    max_alt = min(GeoActivityData.DEFAULT_MAX_ALT, altitude + delta)

                    latitude = self._check_return_value_within_range(
                        GeoActivityData.DEFAULT_MIN_LAT,
                        GeoActivityData.DEFAULT_MAX_LAT,
                        min_lat,
                        max_lat,
                        random.uniform)

                    longitude = self._check_return_value_within_range(
                        GeoActivityData.DEFAULT_MIN_LONG,
                        GeoActivityData.DEFAULT_MAX_LONG,
                        min_long,
                        max_long,
                        random.uniform,
                    )

                    altitude = self._check_return_value_within_range(
                        GeoActivityData.DEFAULT_MIN_ALT,
                        GeoActivityData.DEFAULT_MAX_ALT,
                        min_alt,
                        max_alt,
                        random.uniform,
                    )

        else:
            latitude = random.uniform(  # noqa: S311
                GeoActivityData.DEFAULT_MIN_LAT,
                GeoActivityData.DEFAULT_MAX_LAT,
            )
            longitude = random.uniform(  # noqa: S311
                GeoActivityData.DEFAULT_MIN_LONG,
                GeoActivityData.DEFAULT_MAX_LONG,
            )
            altitude = random.uniform(  # noqa: S311
                GeoActivityData.DEFAULT_MIN_ALT,
                GeoActivityData.DEFAULT_MAX_ALT,
            )

        location_dict["latitude"] = latitude
        location_dict["longitude"] = longitude
        location_dict["altitude"] = altitude
        return location_dict

    # helper for _generate_geo_context()
    def _save_location(self, geo_location: str | dict, geo_command: str) -> dict[str, float]:
        """Saves the geographical location specified in the selected_md_attributes; run once."""
        altitude = 0

        if (isinstance(geo_location, str)):
            geo_py = Nominatim(user_agent="Geo Location Metadata Generator")
            try:
                location = geo_py.geocode(geo_location, timeout=10)
                if location is None:
                    raise ValueError(f"no location found for {geo_location}")  # noqa: TRY301
                latitude = location.latitude
                longitude = location.longitude
                altitude = location.altitude

            except (OSError, ValueError):
                return None

            # save a list of longitude and latitude values if command is within
            if geo_command == "within":
                kilometer_range = self.selected_md["geo_location"]["km"]
                north_bound = geodesic(
                    kilometers = kilometer_range,
                ).destination((latitude, longitude), bearing=0).latitude
                south_bound = geodesic(
                    kilometers = kilometer_range,
                ).destination((latitude, longitude), bearing=180).latitude
                east_bound = geodesic(
                    kilometers = kilometer_range,
                ).destination((latitude, longitude), bearing=90).longitude
                west_bound = geodesic(
                    kilometers = kilometer_range,
                ).destination((latitude, longitude), bearing=270).longitude
                latitude = [south_bound, north_bound]
                longitude = [west_bound, east_bound]
        elif (isinstance(geo_location, dict)):
            latitude = geo_location["latitude"]
            longitude = geo_location["longitude"]
            altitude = geo_location.get("altitude", 0)

        return {"latitude": latitude, "longitude": longitude, "altitude": altitude}

    def _generate_WindowsGPSLocation(  # noqa: N802
        self,
        geo_activity_context: dict[str, float],
        timestamp: datetime,
    ) -> dict[str, Any]:
        """Generate the Windows GPS location in the form of a dictionary."""
        source_list = [ "GPS", "IP" ]
        latitude = geo_activity_context["latitude"]
        longitude = geo_activity_context["longitude"]
        altitude = geo_activity_context["altitude"]
        source = random.choice(source_list)  # noqa: S311

        windows_gps_satellite_location = WindowsGPSLocationSatelliteDataModel(
            geometric_dilution_of_precision=random.uniform(1, 10),  # noqa: S311
            horizontal_dilution_of_precision=random.uniform(1, 10),  # noqa: S311
            position_dilution_of_precision=random.uniform(1, 10),  # noqa: S311
            time_dilution_of_precision=random.uniform(1, 10),  # noqa: S311
            vertical_dilution_of_precision=random.uniform(1, 10),  # noqa: S311
            latitude=latitude,
            longitude=longitude,
            altitude=altitude,
            timestamp=timestamp,
            source=source,
        )

        no_windows_gps_satellite_location = WindowsGPSLocationSatelliteDataModel(
            geometric_dilution_of_precision=None,
            horizontal_dilution_of_precision=None,
            position_dilution_of_precision=None,
            time_dilution_of_precision=None,
            vertical_dilution_of_precision=None,
            latitude=latitude,
            longitude=longitude,
            altitude=altitude,
            timestamp=timestamp,
            source=source,
        )

        # Create a LocationDataModel for the Location field
        location_data = {
            "latitude": latitude,
            "longitude": longitude,
            "altitude": altitude,
            "accuracy": random.uniform(1, 10),  # noqa: S311
            "heading": random.randint(0, 360),  # noqa: S311
            "speed": random.uniform(0, 20),  # noqa: S311
            "timestamp": timestamp,
            "source": "GPS",
        }
        
        from data_models.location_data_model import LocationDataModel
        location = LocationDataModel(**location_data)
        
        # Create semantic attributes
        uuid_longitude = uuid.uuid4()
        uuid_latitude = uuid.uuid4()
        uuid_accuracy = uuid.uuid4()
        
        longitude_identifier = IndalekoUUIDDataModel(Identifier=uuid_longitude, Label="Longitude")
        latitude_identifier = IndalekoUUIDDataModel(Identifier=uuid_latitude, Label="Latitude")
        accuracy_identifier = IndalekoUUIDDataModel(Identifier=uuid_accuracy, Label="Accuracy")
        
        semantic_attributes = [
            IndalekoSemanticAttributeDataModel(
                Identifier=longitude_identifier,
                Value=longitude,
            ),
            IndalekoSemanticAttributeDataModel(
                Identifier=latitude_identifier,
                Value=latitude,
            ),
            IndalekoSemanticAttributeDataModel(
                Identifier=accuracy_identifier,
                Value=random.uniform(1, 10),  # noqa: S311
            ),
        ]
        
        # Create a dummy record if none exists
        from data_models.source_identifier import IndalekoSourceIdentifierDataModel
        
        source_identifier = IndalekoSourceIdentifierDataModel(
            Identifier=uuid.uuid4(),
            Version="1.0",
            Description="Generated by GeoActivityData._generate_WindowsGPSLocation",
        )
        
        record = IndalekoRecordDataModel(
            SourceIdentifier=source_identifier,
        )

        return WindowsGPSLocationDataModel(
            # Base parameters for WindowsGPSLocationDataModel
            latitude=latitude,
            longitude=longitude,
            altitude=altitude,
            accuracy=random.uniform(1, 10),  # noqa: S311
            altitude_accuracy=random.uniform(0, 10),  # noqa: S311
            heading=random.randint(0, 360),  # noqa: S311
            speed=random.uniform(0, 20),  # noqa: S311
            source="GPS",
            timestamp=timestamp,
            is_remote_source=False,
            point=f"POINT({longitude} {latitude})",
            position_source="GPS",
            position_source_timestamp=timestamp,
            satellite_data=random.choice(  # noqa: S311
                [windows_gps_satellite_location, no_windows_gps_satellite_location],
            ),
            civic_address=None,
            venue_data=None,
            
            # Required fields from parent classes
            Record=record,
            Timestamp=timestamp,
            SemanticAttributes=semantic_attributes,
            Location=location,
        )
